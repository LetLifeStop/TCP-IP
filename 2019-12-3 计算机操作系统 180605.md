## 计算机操作系统

* ### 基本特征

  * #### 并发

      宏观上，在同一时间能运行多个程序

  * #### 共享

      同一资源，可以被多个进程同时访问（读操作）

  * #### 虚拟

      将一个物理实体转换成多个逻辑实体，可以分为两种虚拟技术，时分复用技术和空分复用技术

      时分复用技术，多个进程在同一个处理器上并发执行，时间片轮机制

    空分复用技术，虚拟内存。将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到内存中，但是页并不是都放入在内存中，当使用到一个没有在物理内存的页时，执行页面置换算法（如果在页面中，发现所要访问的页面不再内存中，会产生缺页中断。这个时候，如果操作系统中，没有空闲页面，会移除内存中的一个页面（最长时间没有使用），为现在要是用页面在内存中腾出空间，而移除哪个页面，这就是涉及到页面置换算法）
    
  * #### 异步
  
      第一个理解，就是双方不需要共同的时钟，接收方不知道发送方什么时候发送数据，所以在发送的数据中就要包括提示接收方的开始位和接受位
  
      第二个理解，就是多线程的异步处理，当前线程不用阻塞处理，等待其他线程完成任务之后，回调通知这个线程
  
* ### 基本功能
  * #### 进程管理

    进程控制，进程同步，进程通信，死锁处理，处理机调度

  * #### 内存管理

     内存分配，地址映射，虚拟内存

  * #### 文件管理

    目录管理，文件读写管理和保护

  * #### 设备管理

    完成用户的IO请求

* ### 进程与线程

  * #### 进程

  * #### 线程

  * #### 区别

    * 进程是操作系统分配资源的基本单位，线程是CPU进行调度的基本单位
    * 进程拥有独立的地址空间，线程可以看做栈和寄存器的集合，线程的系统开销小
    * 线程直接可以直接读写统一进程中的数据进行通信，进程之间需要借助IPC

* ### 进程状态的切换

  * #### 就绪态

  * #### 运行态

  * #### 阻塞态

    就绪态和运行态之间相互转换，就绪态等待CPU分配时间片，分配完之后进入运行态，分配的时间片没有完成指定任务，重新进入就绪态等待CPU分配时间片

    阻塞态缺少目标资源

* ### 进程调度算法

  * #### 批处理系统

    * **先来先去服务 FCFS**

      不利于短作业

    * **短作业有限服务 SJF**

       不利于长作业

    * **最短剩余时间优先 SRTN** 

      当一个新的作业到达的时候，判断当前进程的剩余时间和新作业的所需时间，如果新的进程需要的时间少，就挂起当前进程，先运行新的进程

  * #### 交互式系统

    * **时间片轮转**

      如果是时间片太小，会导致进程之间切换太频繁，花费过多时间

      如果时间片太大， 实时性无法保证

    * **优先级调度**

      为每个进程分配一个优先级，按照优先级进行调度

    * **多级反馈队列**

      时间片轮转和优先级调度的结合，设置多个队列，每个队列优先级不同，只有当上一个队列没有进程在排队，当前队列的进程才能调度

* ### 进程同步

  * #### 临界区

    对临界资源进行访问的代码称为临界区

  * #### 同步和互斥

    同步是多个进程按照一定的先后关系执行

    互斥是多个进程同一时间只能有一个进程访问临界区

  * #### 信号量

    进化版的互斥锁，可以提升访问共同资源的线程数目

    *生产者消费者模型*

* ### 进程通信

    区别进程通信和进程同步，进程通信是进程间传输，进程同步是控制等多个进程按照一定的顺序执行

  * #### 管道

    只能在父子进程或者兄弟进程中使用，半双工通信

  * #### FIFO 

    允许两个没有血缘关系的进程之间通信，半双工通信

  * #### 消息队列

  * #### 信号量

    * 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法

    * 读今晨够可以根据消息类型有选择的选择消息，不需要想FIFO一样，默认接受
  
  * #### mmap
  
    * 允许多个进程共享一个存储区
  
  * #### 套接字
  
    * 可以用于不同机器间的进程通信



# 死锁

* ### 必要条件

  * #### 互斥

  * #### 环形条件

* ### 处理方法

  * #### 鸵鸟政策

  * #### 当获取对方资源的时候，先放弃自己手中的部分资源



## 内存管理

* ### 虚拟内存

  虚拟内存的目的是为了增大物理内存的逻辑大小，给程序生成更多的可用内存

  每个程序的虚拟内存按照块来进行划分，每一块称为页，这些页通过mmu映射到物理内存中，当程序引用到没有在物理内存的页时，产生缺页中断，此时会产生系统调用，如果此时内存没有空闲的页，通过页面置换算法将长时间不用或者用的时候比较晚的页置换出来，将缺失的部分的页重新装入内存中，重新执行指令

* ### 分页系统地址映射

  mmu 内存管理单元，管理着进程地址空间和物理内存的对应情况，页表存储着页（进程地址空间）和页框（物理内存空间）的映射表

* ### 页面置换算法

  在程序运行的期间，如果访问的内存对应的页面不在内存中，就会发生缺页中断，下一步操作系统会讲该页调入内存中，如果此时内存中没有足够的内存，操作系统会从内存中调出一个页面来腾空间，

  腾出哪个页面

  * #### 最长时间内不再被访问

  * #### 最近最久没有使用

  * #### 先进先出

* ### 分段

  编译器在编译的过程中建立多个表，有的表是动态增长的，把每个表分成段，一个段构成一个独立的地址空间

  如果使用分页系统的一维空间，动态增长的特点导致覆盖问题的出现。

  把每个表分成段，一个段构成一个独立的地址空间，每个段的长度不同，并且可以动态增长

* ### 段页式

  程序的地址空间分成多个具有独立地址空间的段，每个段上的地址空间分成相同的页。

* ### 分页和分段的比较

  * 分页透明，分段需要程序员显式的划分每一段
  * 分页是一维的，分段是二维的
  * 页的代销不能该表，段的大小可以改变
  * 分页主要用于虚拟内存的实现，获得更大的逻辑内存；分段是为了数据可以显式的划分成逻辑上的独立的地址空间并且有助于共享和保护

ps：

* #### mmap内存映射机制？

  mmap内存映射，是从用户空间到内核空间的相互映射。文件系统负责将硬盘映射到内核中的高速cache中，mmap将缓冲页映射到用户地址空间，这样在用户空间进行操作的时候，相当于对cache进行了操作，文件系统中的内核线程会将脏的cache回写到硬盘上

  mmap返回的指针是一个指向进程逻辑地址空间的地址，

* #### mmap内存映射效率为什么比read/write效率高？

  文件系统负责将硬盘映射到内核中的高速cache区中，mmap将缓冲页映射到用户地址空间；这样进行在用户空间的操作，相当于直接操作了cache，文件系统会将数据回写到硬盘；

  read/write等系统调用操作文件，首先，read会先将硬盘对应的文件copy到内核cache中，然后再将这些数据拷贝到用户空间。write是先从用户态写到内核的cache中，然后文件系统中的内核线程，在将cache再写回到硬盘上。

  read/write是系统调用，其中进行了数据拷贝。先将文件内容从硬盘拷贝到用户内核空间的缓冲区（物理内存中），然后再将这些数据拷贝到用户空间（物理内存中），进行了两次拷贝。而mmap是直接将文件映射到用户空间，所以在通过返回的指针第一次访问内存的时候，由于会产生缺页中断，中断处理函数直接根据这个映射关系，将数据从文件拷贝到用户空间，只进行了一次数据拷贝    

* #### 操作系统的分页机制？

虚拟内存按照固定的大小划分成页面的若干单元，在物理内存中对应的单元称为页框。每个进程会有一张页表，记录进程逻辑地址和内存物理页面的关系。页表中比较重要的几个位置，页框号， 在/不在位（表示该表项对应的虚拟页在不在内存中，如果不在的话，会引起缺页中断）

