## 计算机操作系统

* ### 基本特征

  * #### 并发

      宏观上，在同一时间能运行多个程序

  * #### 共享

      同一资源，可以被多个进程同时访问（读操作）

  * #### 虚拟

      将一个物理实体转换成多个逻辑实体，可以分为两种虚拟技术，时分复用技术和空分复用技术

      时分复用技术，多个进程在同一个处理器上并发执行，时间片轮机制

    空分复用技术，虚拟内存。将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到内存中，但是页并不是都放入在内存中，当使用到一个没有在物理内存的页时，执行页面置换算法（如果在页面中，发现所要访问的页面不再内存中，会产生缺页中断。这个时候，如果操作系统中，没有空闲页面，会移除内存中的一个页面（最长时间没有使用），为现在要是用页面在内存中腾出空间，而移除哪个页面，这就是涉及到页面置换算法）
    
  * #### 异步
  
      第一个理解，就是双方不需要共同的时钟，接收方不知道发送方什么时候发送数据，所以在发送的数据中就要包括提示接收方的开始位和接受位
  
      第二个理解，就是多线程的异步处理，当前线程不用阻塞处理，等待其他线程完成任务之后，回调通知这个线程
  
* ### 基本功能
  * #### 进程管理

    进程控制，进程同步，进程通信，死锁处理，处理机调度

  * #### 内存管理

     内存分配，地址映射，虚拟内存

  * #### 文件管理

    目录管理，文件读写管理和保护

  * #### 设备管理

    完成用户的IO请求

* ### 进程与线程

  * #### 进程

  * #### 线程

  * #### 区别

    * 进程是操作系统分配资源的基本单位，线程是CPU进行调度的基本单位
    * 进程拥有独立的地址空间，线程可以看做栈和寄存器的集合，线程的系统开销小
    * 线程直接可以直接读写统一进程中的数据进行通信，进程之间需要借助IPC

* ### 进程状态的切换

  * #### 就绪态

  * #### 运行态

  * #### 阻塞态

    就绪态和运行态之间相互转换，就绪态等待CPU分配时间片，分配完之后进入运行态，分配的时间片没有完成指定任务，重新进入就绪态等待CPU分配时间片

    阻塞态缺少目标资源

* ### 进程调度算法

  * #### 批处理系统

    * **先来先去服务 FCFS**

      不利于短作业

    * **短作业有限服务 SJF**

       不利于长作业

    * **最短剩余时间优先 SRTN** 

      当一个新的作业到达的时候，判断当前进程的剩余时间和新作业的所需时间，如果新的进程需要的时间少，就挂起当前进程，先运行新的进程

  * #### 交互式系统

    * **时间片轮转**

      如果是时间片太小，会导致进程之间切换太频繁，花费过多时间

      如果时间片太大， 实时性无法保证

    * **优先级调度**

      为每个进程分配一个优先级，按照优先级进行调度

    * **多级反馈队列**

      时间片轮转和优先级调度的结合，设置多个队列，每个队列优先级不同，只有当上一个队列没有进程在排队，当前队列的进程才能调度

* ### 进程同步

  * #### 临界区

    对临界资源进行访问的代码称为临界区

  * #### 同步和互斥

    同步是多个进程按照一定的先后关系执行

    互斥是多个进程同一时间只能有一个进程访问临界区

  * #### 信号量

    进化版的互斥锁，可以提升访问共同资源的线程数目

    *生产者消费者模型*

* ### 进程通信

    区别进程通信和进程同步，进程通信是进程间传输，进程同步是控制等多个进程按照一定的顺序执行

  * #### 管道

    只能在父子进程或者兄弟进程中使用，半双工通信

  * #### FIFO 

    允许两个没有血缘关系的进程之间通信，半双工通信

  * #### 消息队列

  * #### 信号量

    * 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法

    * 读今晨够可以根据消息类型有选择的选择消息，不需要想FIFO一样，默认接受
  
  * #### mmap
  
    * 允许多个进程共享一个存储区
  
  * #### 套接字
  
    * 可以用于不同机器间的进程通信



# 死锁

* ### 必要条件

  * #### 互斥

  * #### 环形条件

* ### 处理方法

  * #### 鸵鸟政策

  * #### 当获取对方资源的时候，先放弃自己手中的部分资源



## 内存管理

* ### 虚拟内存

  虚拟内存的目的是为了增大物理内存的逻辑大小，给程序生成更多的可用内存

  每个程序的虚拟内存按照块来进行划分，每一块称为页，这些页通过mmu映射到物理内存中，当程序引用到没有在物理内存的页时，产生缺页中断，此时会产生系统调用，如果此时内存没有空闲的页，通过页面置换算法将长时间不用或者用的时候比较晚的页置换出来，将缺失的部分的页重新装入内存中，重新执行指令

* ### 分页系统地址映射

  mmu 内存管理单元，管理着进程地址空间和物理内存的对应情况，页表存储着页（进程地址空间）和页框（物理内存空间）的映射表

* ### 页面置换算法

  在程序运行的期间，如果访问的内存对应的页面不在内存中，就会发生缺页中断，下一步操作系统会讲该页调入内存中，如果此时内存中没有足够的内存，操作系统会从内存中调出一个页面来腾空间，

  腾出哪个页面

  * #### 最长时间内不再被访问

  * #### 最近最久没有使用

  * #### 先进先出

* ### 分段

  编译器在编译的过程中建立多个表，有的表是动态增长的，把每个表分成段，一个段构成一个独立的地址空间

  如果使用分页系统的一维空间，动态增长的特点导致覆盖问题的出现。

  把每个表分成段，一个段构成一个独立的地址空间，每个段的长度不同，并且可以动态增长

* ### 段页式

  程序的地址空间分成多个具有独立地址空间的段，每个段上的地址空间分成相同的页。

* ### 分页和分段的比较

  * 分页透明，分段需要程序员显式的划分每一段
  * 分页是一维的，分段是二维的
  * 页的大小不能改变，段的大小可以改变
  * 分页主要用于虚拟内存的实现，获得更大的逻辑内存；分段是为了数据可以显式的划分成逻辑上的独立的地址空间并且有助于共享和保护



## 链接

​	编译的四个阶段

* ### 预处理（hello.c  > hello.i）

  处理以#开头的预处理命令

* ### 编译 （hello.i > hello.s）

  将文件翻译成汇编文件

* ### 汇编（hello.s > hello.o）

  将汇编文件翻译成可重定位目标文件

* ### 链接（hello.o > 可执行文件）

  将可重定位目标文件和printf.o等编译好的目标文件进行合并，得到最终可以执行的目标文件



## 目标文件

* ### 可执行目标文件

  可以直接在内存中运行

* ### 可重定位目标文件

  可以和其他重定位目标文件在链接阶段合并，创建一个可执行文件

* ### 共享目标文件

  特殊的可重定位目标文件，可以在运行的时候动态的加载进内存实现链接



## 动态链接和静态链接

* ### 静态链接

  以一组可重定位目标文件为输入，生成一个可执行文件作为输出

  #### 优点

  * 加载速度快
  * 不需要打包库

  #### 缺点

  * 程序发生改变需要重新编译
  * 可执行文件体积大

* ### 动态链接

  在内存中，一个共享的.text节的一个副本可以被不同的进程共享

  #### 优点

  * 在函数接口不变的前提下，不需要重新编译
  * 体积小

  #### 缺点

  * 加载速度慢
  * 需要打包库





# Linux		

* ### 目录

  * /bin

    存储命令

  * /dev

    存放外部设备

  * /etc

    存放配置文件

  * /home

    用户的主目录

  * /lib

    动态共享库

  * media

    电脑自动挂载外设

  * mnt

    当自动挂载外设失败的时候，手动挂载

* ### 文件类型

  * d

    目录

  * p

    管道

  * f

    **普通文件**

  * l

    **链接符号**

  * b

    块设备

  * c

    字符设备

  * s

    socket文件

* ### 软链接和硬链接

  * #### 硬连接

    命令

    ```git
    ln 文件名 硬链接的名称
    ```

    指向的文件对应的inode节点，如果对文件进行修改，硬链接对应的内容也会进行修改

  * #### 软链接

    命令

    ```
    ln -s 文件名
    ```

    相当于创建了一个快捷方式，快捷方式既可以使用绝对路径，也可以使用相对路径，绝对路径无论这个文件移动到哪里都可以打开，相对路径只能在当前文件夹下打开。如果源文件消失，软连接失去意义，而硬链接还是存在意义的

* ### 查看电脑情况

  * lscpu

    查看电脑相关的情况

  * ifconfig

    查看网络配置

  * du -h

    查看当前目录所占的大小

  * df -h

    磁盘的使用情况

  * whoami

    查看当前用户名

  * pstree

    查看进程树

  * netstat

    查看占用端口的进程

  * top

    实时显示进程信息

* ### inode节点机制

  * #### 为什么要有inode节点机制？

    * 如果文件包含特殊的字符，无法直接删除，可以通过直接删除inode节点的方式
    * 如果进行更新，可以新建一个inode节点，当文件重新打开的时候，将原来的文件指向这个新的inode节点
    * 对文件进行重命名或者移动，不会影响inode节点

  * ### inode节点机制

    ​	每个进行会分配虚拟地址，在3G~4G区域中，存在PCB进程控制块，PCB中存在文件描述符表，文件描述符就是这个表的下标

     	在一个file结构体中，记录着这个文件的引用次数，还有指向file_operations（封装了函数）结构体的指针，还有指向dentry结构体的指针，在dentry结构体中，有一个指向inode结构体的指针，这个结构体保存了文件的所有者，块的大小，属性，位置等等

* ### 孤儿进程和僵尸进程

* ### SIGCHLD

  当一个子进程的状态发生改变（停止运行，继续运行，退出），父进程会受到子进程发过来的SIGCHLD信号，这个信号中包含的进程的ID，状态，CPU时间等等

  当子进程退出的时候，会发送这个信号给父进程，让父进程通过wait或者waitpid来进行对资源的回收



## 计算机网络

* ### 体系

  * #### 应用层

    为用户应用程序提供网络服务器的接口   （数据）

  * #### 传输层

    为进程之间提供端到端的逻辑通信   （TCP/UDP 头部）

  * #### 网络层

    把传输层传递下来的报文段或者数据报封装成分组，实现两个主机系统之间的透明传送 （ip TCP/UDP 头部）

  * #### 链路层

    把网络层传下来的分组 封装成帧

  * #### 物理层

    为上层协议提供一个传输数据的可靠媒介

* ### TCP报文格式，UDP报文格式，IP头部格式

  * TCP

     ![img](https://img-blog.csdn.net/20180603234043215?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwMTc3ODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

     

  * UDP

     ![img](https://img-blog.csdn.net/20180603234609375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwMTc3ODM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

  * IP

     ![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=fd98306e0623dd54357eaf3ab060d8bb/c8177f3e6709c93d464442fd903df8dcd1005401.jpg) 
    * 版本： IPV4，IPV6
    * 首部长度：IP数据报首部长度
    * 服务类型：获得更好的服务，一般不用
    * 总长度：IP数据报总长度
    * 标识：当数据报要进行分片的时候，通过这个标识使得各数据片最后能正确的组装成原来的数据报
    * 标志：占三个位，第二个位标记是否能分片，第三个为标记后面是否还有分片
    * 片偏移：该片相对于起点，这个片从哪里开始
    * 生存时间：TTL，防止数据包瞎转
    * 协议：TCP，UDP
    * 首部检验和：检验
    * 源地址
    * 目的地址

* ### ARP地址协议

  地址解析协议，当我们在网络中想要和另一台电脑进行通信，是需要获取对方的MAC地址，通过arp协议即可实现。对方的IP地址是用来进行定位的，当前电脑要和某一个IP对应的电脑进行通信，首先在查看本地的arp高速缓存表，查看本IP是否有对应的MAC地址。如果存在的话，即可进行通信。如果没有的话， 会在局域网进行广播，询问要访问的IP对应的MAC地址是什么，该IP对应的电脑收到广播之后，就会将自己的MAC地址发送给询问方，询问方会进行动态记录，双方即可进行通信

  存储的时候有两种方式，静态头目和动态头目，静态可以自己添加。动态的会定期刷新。
  
* ### ICMP

  网际控制报文协议，为了更有效的转发IP数据报和提高交付成功的机会。封装在IP协议中
  
* ### HTTP

  * #### URI（Uniform Resource Identifier）（统一资源标识符）

    包含：

    * URL（Uniform Resource Locator）（统一资源定位符）

      ```
      https://www.google.com
      ```

    * URN（Uniform Resource Name）（统一资源名称）

      ```
      urn:isbn:324322
      ```

  * #### 请求和响应报文

    * 请求报文

      ```
      GET /doc/test.html HTTP/1.1
      Host: www.test101.com
      Accept: image/gif, image/jpeg
      Accept-Language: en-us
      Accept-Encoding: gzip, deflate
      User-Agent: Mozilla/4.0
      Content-Length: 35
      
      bookId=12345&author=Tan+Ah+Teck
      ```

      ![img](https://images2018.cnblogs.com/blog/1418466/201808/1418466-20180812195817248-854519361.png)

    * #### 响应报文

      ```
      HTTP/1.1 200 OK																	-- 状态行
      Data: Sun, 08 Feb xxxx 	01:11:12								  --
      Server: Apache/1.3.29 (Win32)										|			
      Last-Modified: Sat. 07, Feb xxxx										消息报头
      ETag: "0-23-4024c3a5"														|
      Accept-Ranges: bytes														  |
      Content-Length: 35																|	
      Connection: close																  |
      Content-Type: test/html												__  |		
      (\r\n)																						   -- 空行	
      <h1>My Home page</h1>												-- 响应正文		
      ```

  * ### HTTP方法

    客户端发送的请求第一行包含了HTTP方法

    * GET

      请求网页主体，返回报文实体部分

    * POST

      用来传输数据

    * HEAD

      和GET类似，不过不返回报文实体部分，主要确认URL的有效性，资源的更新时间

    * PUT

      任何人都可以上传文件

    * DELETE

      任何人都可以卸载文件

    * PATCH

      对资源进行部分修改

    * OPTIONS

      查看指定的URL能够支持的方法

  * HTTP状态码

    ​	https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md

  * cookie和session

  * 幂等性

    幂等的HTTP方法，同样的请求被执行一此和连续执行多次的效果是一样的，服务器的状态也是一样的    

  * 

https://camo.githubusercontent.com/

ps：

* #### mmap内存映射机制？

  mmap内存映射，是从用户空间到内核空间的相互映射。文件系统负责将硬盘映射到内核中的高速cache中，mmap将缓冲页映射到用户地址空间，这样在用户空间进行操作的时候，相当于对cache进行了操作，文件系统中的内核线程会将脏的cache回写到硬盘上

  mmap返回的指针是一个指向进程逻辑地址空间的地址，

* #### mmap内存映射效率为什么比read/write效率高？

  文件系统负责将硬盘映射到内核中的高速cache区中，mmap将缓冲页映射到用户地址空间；这样进行在用户空间的操作，相当于直接操作了cache，文件系统会将数据回写到硬盘；

  read/write等系统调用操作文件，首先，read会先将硬盘对应的文件copy到内核cache中，然后再将这些数据拷贝到用户空间。write是先从用户态写到内核的cache中，然后文件系统中的内核线程，在将cache再写回到硬盘上。

  read/write是系统调用，其中进行了数据拷贝。先将文件内容从硬盘拷贝到用户内核空间的缓冲区（物理内存中），然后再将这些数据拷贝到用户空间（物理内存中），进行了两次拷贝。而mmap是直接将文件映射到用户空间，所以在通过返回的指针第一次访问内存的时候，由于会产生缺页中断，中断处理函数直接根据这个映射关系，将数据从文件拷贝到用户空间，只进行了一次数据拷贝    

* #### 操作系统的分页机制？

虚拟内存按照固定的大小划分成页面的若干单元，在物理内存中对应的单元称为页框。每个进程会有一张页表，记录进程逻辑地址和内存物理页面的关系。页表中比较重要的几个位置，页框号， 在/不在位（表示该表项对应的虚拟页在不在内存中，如果不在的话，会引起缺页中断）







