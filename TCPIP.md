#### 访问www.baidu.com 到返回结果显示的过程

1. 输入网址
2. DNS解析
   * 首先查看本机的hosts文件，看有没有和这个域名对应的规则，如果有的话，直接使用hosts文件里面的ip地址
   * 如果本机的hosts文件中没有找到对应的ip地址，浏览器会发出一个DNS（域名系统，域名和ip地址相互映射的一个分布式数据库）请求到本地服务器
   * 本地服务器会查询缓存记录，如果有的话直接返回结果。如果没有的话，递归往DNS根服务器查询。
   * 根服务器并没有记录具体的域名和ip地址的对应关系，而是告诉本地的DNS服务器，可以到域服务器上继续查询，并且给出域服务器的地址
   * 域服务器收到请求之后，告诉本地服务器，你所需要的域名的解析服务器地址
   * 然后本地服务器向域名的解析服务器发出请求，这个时候就能收到域名和ip地址的对应关系，然后本地DNS服务器把ip地址返回到用户电脑，然后把这个对应关系保存到本地的hosts文件当中
3. 浏览器与web服务器之间通过TCP三次握手建立链接
4. 服务收到客户端发来的http数据请求，查询自己服务器得到对应的结果，将结果原路返回
5. 浏览器通过渲染效果来显示网页



#### TCP和UDP的区别

TCP是一种面向连接的可靠的数据流传输服务，UDP是一种非面向对象（面向事务）的不可靠的数据报传输服务



#### TCP三次握手，四次握手

三次握手：

* 客户端向服务器端通过报文的形式发送链接请求，此时ACK = 0， seq = x（通信的字节流），SYN = 1（同步序列编号，仅在三次握手建立TCP链接的时候有效）此时客户端进入SYS_RCVD状态
* 服务器端在收到客户端的报文的时候，会回复一个报文，此时ACK = 1， seq = y，ack = x + 1，此时服务器端进入SYS_WAIT状态
* 客户端在收到服务器端的回复之后，会向服务器端继续返回一个报文，这个报文中 ACK = 1，seq = x + 1， ack = y + 1.之后，客户端和服务器端都进入ESTABLISHED状态

四次握手：

* 客户端向服务器端通过豹纹的形式发送请求释放的链接，此时FIN = 1，seq = z，然后客户端进入了CLOSE_WAIT1状态
* 服务器端收到客户端发来的报文的之后，会回复给客户端一个报文。此时FIN = 1，seq = w，ack = z + 1，ACK = 1，客户端收到这个报文之后，进入CLOSE_WAIT2状态
* 服务器端向客户端发送请求断开连接的报文，FIN = 1，seq = v，ack = z + 1，然后服务器端进入LAST_ACK状态
* 客户端收到这个报文的时候，就进入了TIME_WAIT状态。如果2msl的时间内，服务器端没有重发请求，就会回复给服务器端一个报文，FIN = 1，seq = z + 1,ack = v + 1



### 为什么是三次握手

​	如果客户端发送的请求连接报文并没有及时到达，而是在某个节点堵塞，然后客户端会第二次发送请求连接报文，假设这次连接成功，然后服务器端也顺利回复了一个报文。等到连接结束后，第一次发送的请求连接报文才到达服务器，而服务器收到了之前的报文就直接进入了ESTABLISHED状态，而此时客户端并没有意思要向客户端建立链接， 这样服务器端就会造成一个资源的浪费。如果是三次握手的话，就能避免这个状态



#### 为什么关闭的时候是四次握手

​	当关闭连接的时候，服务器端收到FIN报文的时候，很有可能并不会直接关闭，只能先回复一个ACK应答， 告诉你你要关闭这个信息我收到了，只有当服务器端所有的报文都发送完了，服务器端才会向客户端发送FIN报文



#### 为什么客户端在发送完最后一次报文的时候进入TIME_WAIT状态，并且等待2MSL才会返回close状态

​	如果网络出现问题，客户端发送的最后一次报文并没有到达服务器端。服务器端如果没有收到客户端返回的报文，会一直发送FIN报文，如果在2MSL这段时间，再次收到服务器端发送的FIN报文，客户端会继续向服务器端发送报文，并且再次等待2MSL。之所以是2MSL的原因，MSL（max segment lifetime），一个片段在网络中存活的最长时间，如果2MSL过后，服务器端再没有收到FIN报文，就证明服务器端已经收到了我发送的报文，结束TCP链接。

如果已经建立了链接，但是服务器突然出现故障，怎么处理

​	TCP设有一个保活计时器，如果在2小时内，客户端没有给服务器端发送任何数据，服务器端就会发送一个探测报文端，然后每隔75s发送一个，如果一连发送10个，客户端都没有回应，就关闭连接

#### TCP构成（头部）

https://www.cnblogs.com/QingFlye/p/4442529.html

**16位源端口号** 16位目的端口号 （唯一确认一个TCP连接）

**32位序号**（标记TCP发送端向TCP收端发送的数据字节流）

**32位确认序号**（发送确认的一端所期望收到的下一个序号，值 = 收到数据字节序号 + 1，ACK标志为1时，确认序号有效）

**4位首部长度**   指的是TCP数据报起始位置和TCP报文数据的距离

**保留**（6位）

**URG** 紧急指针

**ACK** 确认序号

**PSH** 接收应尽快将这个报文段交给应用层

**RST** 重建连接

**SYN** 同步序号用来发起一个连接

**FIN** 发送端完成发送任务

**16位窗口大小** 告诉对方在不等待确认的情况下，可以发来多大的数据

**16位检验和** 检验

**16位紧急指针** 当URG为1是有效

**选项**  mss

#### MSS 和 MTU

MSS （maximum segment size 最大报文长度） TCP建立时，收发双方协商通信的每一个报文段所能承载的最大数据分段

MTU（maximum transmission unit 最大传输单元）一种通信协议的某一层上所能通过的最大数据报大小

MSS加上TCP报头的数据就等于MTU

#### 一个TCP报文最多传输多少字节数  

1460

#### 如果文件大于1480字节，TCP如何进行处理

拆包

#### TCP为什么可靠

* 超时重传机制

* 快速重传机制

* 快速恢复机制

* 滑动窗口

* 慢启动

* 拥塞避免

  

#### 如果要让UDP保证数据完整，该怎么做

可以参考TCP的重传机制，可以在应用层模拟重传机制

#### http

超文本传输协议，基于TCP/IP通信协议来传递数据



#### http特点

1. 支持B/S模式
2. 简单快速，客户端向服务器端请求服务的时候，只需要传送请求方法和路径
3. 灵活，允许传输任何类型的数据对象
4. 无连接，限制每次连接只处理一个请求。为了弥补这个不足，加入了cookie和session
5. 无状态，对于事务处理没有记忆，后续处理需要前面的信息，就必须重传
6. 请求的数据是明文传输，容易被窃听
7. 数据的完整性未校验，容易被篡改
8. 没有验证对方身份，存在冒充的可能性



#### https特点

1. https 是在http协议基础上加上加密处理和认证机制，完整性保护。也就是说 http + 认证 + 完整性保护 =  https

2. 多次握手，页面加载时间边变长

3. https链接缓存不如http效率高，会增加数据开销和功耗

4. 申请SSL花钱，，，，

5. SSL设计到的安全算法会消耗CPU资源

6. SSL分为两类，SSL记录协议，为高层协议提供数据封装，压缩，加密等基本功能；SSL握手协议，建立在SSL记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证，协商加密算法，交换加密密钥等

   

#### HTTP和HTTPS的区别

1.  https协议需要用到CA申请证书，花钱

2. 连接方式不一样（原来是http和tcp通信，当使用ssl的时候，演变成http先和ssl通信，再由ssl和tcp通信），端口号也不一样。http端口号是80，https是443



#### 如何优化HTTP

1. 多路复用
2. 压缩头信息
3. 请求划分优先级
4. 支持服务器端主动推送



#### 状态码301,302,400,401,404,503,504

301 页面永久移走，表示本网页永久性专业到另一个地址

302 暂时性重定向

400 服务器不理解请求的语法

401 请求身份验证

404 所请求的页面不存在或者被删除

503 用户正在访问的网站服务器繁忙，负载过重，无法及时响应用户的请求

504 服务器作为网关或者代理，没有及时从上游服务器收到请求，表示上游服务器已经关闭

1**： 消息服务器已收到，需要请求者继续操作

2**：成功（200）

3**：重定向，需要进一步操作完成请求

4**：客户端错误

5**：服务器错误



#### URI，URL，URN

URN和URL是URI的子集

URI，统一资源标志符

通过唯一的标识来实现

URL，统一资源定位符

通过定位的方式来实现，指定了操作或获取方式

但是举个例子，URI标记的是身份中，然后

URN

唯一标识一个实体的表示符



#### post，get

1. 传送方式：get通过地址栏传输，post通过报文传输
2. 传送长度：get参数有长度限制，post无限制
3. get产生一个TCP数据包， POST产生两个数据包（并不是所有的浏览器）。一个数据包就直接把http和data一并发过去；两个数据包的是，第一趟先发送header，第二趟发送continue
4. post的安全性比get好
5. 数据查询的时候建议用get；添加，修改，删除的时候，用post、



#### 连接，流，帧的关系

一个连接可以被多个流复用

一个流代表依次完整的请求/相应的过程，包含多个帧

一个消息被拆分封装成多个帧



